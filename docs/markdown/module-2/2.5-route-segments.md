# 2.5 route_segments

  
https://gemini.google.com/u/1/app/9ed6b32c76b55d3a?is_sa=1&android-min-version=3
01356232&ios-min-version=322.0&campaign_id=bkws&utm_source=google&utm_medium=cpc
&utm_campaign=2024enUS_gemfeb&pt=9008&mt=8&ct=p-growth-sem-bkws 
https://gemini.google.com/u/1/app/8d62cfd96b565ac8 
https://gemini.google.com/u/1/app/2d30425fc8a5984a * * * * * ### Updated 
Production-Ready Specification Table Name: `public.route_segments` 1\. Purpose 
& Primary Use-Cases This linking table defines the precise, ordered sequence of 
segments that constitute a specific route. It is fundamental for constructing 
navigable paths, displaying coherent itineraries, and enabling the accurate 
aggregation of route-level statistics like total distance and elevation gain 
via a critical trigger mechanism. Key User-Story Touchpoints: - Pilgrim (Anna) 
- Story A2 (Daily Stage Understanding): This table directly provides the 
sequence of segments that the application uses to build and display daily 
"stages" of a chosen route. - Pilgrim (Anna) - Story A7 (Using Pre-defined 
Itineraries): If curated itineraries are built upon standard routes, this table 
defines the composition of those underlying routes. - Platform Administrator 
(Admin Team) - Story D1 & D2: Admins manage the assembly of segments into 
routes using this table. - Application Logic - Route Statistics Calculation: ðŸ”´ 
DML operations (INSERT, UPDATE, DELETE) on this table are critical triggers for 
updating aggregated statistics on the parent `routes` table. 2\. Schema | 
Column Name | Data Type | Constraints | Description (Translatable fields 
marked) | | `id` | `bigint` | PRIMARY KEY, GENERATED ALWAYS AS IDENTITY | 
Unique identifier for this specific route-segment link record. | | `route_id` | 
`bigint` | NOT NULL, REFERENCES `public.routes(id)` ON DELETE CASCADE | The ID 
of the route this segment sequence belongs to. | | `segment_id` | `bigint` | 
NOT NULL, REFERENCES `public.segments(id)` ON DELETE CASCADE | The ID of the 
segment that forms part of this route. | | `order_in_route` | `integer` | NOT 
NULL, CHECK (`order_in_route` > 0) | The sequential, 1-based order of this 
segment within this route. Critical for path reconstruction. | | 
`contextual_notes_for_segment_in_route` | `text` | | Optional notes specific to 
this segment when it is part of this particular route (English base). 
(Translatable via `public.translations`) | | `created_at` | `timestamptz` | NOT 
NULL DEFAULT `now()` | Timestamp indicating when this link record was created. 
| | `created_by_profile_id` | `uuid` | REFERENCES `public.profiles(id)` ON 
DELETE SET NULL | Profile ID of the user who created this link. | | 
`updated_at` | `timestamptz` | NOT NULL DEFAULT `now()` | Timestamp indicating 
when this link record was last updated (auto-updated by trigger). | | 
`updated_by_profile_id` | `uuid` | REFERENCES `public.profiles(id)` ON DELETE 
SET NULL | Profile ID of the user who last updated this link. | | | | UNIQUE 
(`route_id`, `order_in_route`) | Ensures segment order is unique for each 
route. | 3\. PostgreSQL DDL SQL ``` -- This DDL assumes that 'public.routes', 
'public.segments', -- and 'public.profiles' tables already exist. CREATE TABLE 
public.route_segments ( id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY, -- 
[cite: 624] route_id BIGINT NOT NULL REFERENCES public.routes(id) ON DELETE 
CASCADE, -- [cite: 624] segment_id BIGINT NOT NULL REFERENCES 
public.segments(id) ON DELETE CASCADE, -- [cite: 624] order_in_route INTEGER 
NOT NULL CHECK (order_in_route > 0), -- [cite: 624] 
contextual_notes_for_segment_in_route TEXT, -- [cite: 624] created_at 
TIMESTAMPTZ NOT NULL DEFAULT now(), -- [cite: 624] created_by_profile_id UUID 
REFERENCES public.profiles(id) ON DELETE SET NULL, -- [cite: 624] updated_at 
TIMESTAMPTZ NOT NULL DEFAULT now(), -- [cite: 624] updated_by_profile_id UUID 
REFERENCES public.profiles(id) ON DELETE SET NULL, -- [cite: 624] UNIQUE 
(route_id, order_in_route) -- [cite: 625] ); -- Indexes CREATE INDEX IF NOT 
EXISTS idx_route_segments_route_id ON public.route_segments(route_id); -- 
[cite: 626] CREATE INDEX IF NOT EXISTS idx_route_segments_segment_id ON 
public.route_segments(segment_id); -- [cite: 626] -- The UNIQUE constraint on 
(route_id, order_in_route) automatically creates an efficient index. [cite: 
627] -- Trigger for standard audit fields (created_by, updated_by, updated_at) 
CREATE OR REPLACE FUNCTION public.set_route_segment_modification_meta() RETURNS 
TRIGGER AS $$ BEGIN NEW.updated_at = NOW(); -- [cite: 628] IF (TG_OP = 
'INSERT') THEN NEW.created_by_profile_id = auth.uid(); -- [cite: 629] 
NEW.updated_by_profile_id = auth.uid(); -- [cite: 629] ELSIF (TG_OP = 'UPDATE') 
THEN NEW.updated_by_profile_id = auth.uid(); -- [cite: 630] NEW.created_at = 
OLD.created_at; -- [cite: 630] NEW.created_by_profile_id = 
OLD.created_by_profile_id; -- [cite: 630] END IF; RETURN NEW; -- [cite: 631] 
END; $$ LANGUAGE plpgsql SECURITY DEFINER; -- [cite: 631] CREATE TRIGGER 
trigger_route_segments_modification_meta BEFORE INSERT OR UPDATE ON 
public.route_segments FOR EACH ROW EXECUTE FUNCTION 
public.set_route_segment_modification_meta(); -- [cite: 632] -- ðŸ”´ Crucial: 
Trigger to update routes.total_distance_km and 
routes.estimated_total_elevation_gain_meters CREATE OR REPLACE FUNCTION 
public.update_route_aggregates_from_segments() RETURNS TRIGGER AS $$ DECLARE 
v_route_id BIGINT; -- [cite: 633] BEGIN IF (TG_OP = 'DELETE') THEN v_route_id 
:= OLD.route_id; -- [cite: 634] ELSE -- INSERT or UPDATE v_route_id := 
NEW.route_id; -- [cite: 635] END IF; -- This assumes segments table's own 
triggers have fired or data is accurate. [cite: 637] UPDATE public.routes SET 
total_distance_km = ( SELECT COALESCE(SUM(s.distance_km), 0) FROM 
public.route_segments rs JOIN public.segments s ON rs.segment_id = s.id WHERE 
rs.route_id = v_route_id ), -- [cite: 638] 
estimated_total_elevation_gain_meters = ( SELECT 
COALESCE(SUM(s.elevation_gain_meters), 0) FROM public.route_segments rs JOIN 
public.segments s ON rs.segment_id = s.id WHERE rs.route_id = v_route_id ) -- 
[cite: 639] WHERE id = v_route_id; -- [cite: 639] IF (TG_OP = 'UPDATE' AND 
NEW.route_id IS DISTINCT FROM OLD.route_id) THEN UPDATE public.routes SET 
total_distance_km = ( SELECT COALESCE(SUM(s.distance_km), 0) FROM 
public.route_segments rs JOIN public.segments s ON rs.segment_id = s.id WHERE 
rs.route_id = OLD.route_id ), -- [cite: 641] 
estimated_total_elevation_gain_meters = ( SELECT 
COALESCE(SUM(s.elevation_gain_meters), 0) FROM public.route_segments rs JOIN 
public.segments s ON rs.segment_id = s.id WHERE rs.route_id = OLD.route_id ) -- 
[cite: 642] WHERE id = OLD.route_id; -- [cite: 643] END IF; RETURN NULL; -- 
Result is ignored since this is an AFTER trigger [cite: 644] END; $$ LANGUAGE 
plpgsql SECURITY DEFINER; -- [cite: 644] CREATE TRIGGER 
trigger_route_segments_after_change_update_route_stats AFTER INSERT OR UPDATE 
OR DELETE ON public.route_segments FOR EACH ROW EXECUTE FUNCTION 
public.update_route_aggregates_from_segments(); -- [cite: 645] -- Comments 
COMMENT ON TABLE public.route_segments IS 'Defines the ordered sequence of 
segments that constitute a specific route. This table is critical for path 
construction and route statistic aggregation. Version: V2.'; -- [cite: 646] 
COMMENT ON COLUMN public.route_segments.id IS 'Unique identifier for this 
route-segment link record. Version: V2.'; -- [cite: 647] COMMENT ON COLUMN 
public.route_segments.route_id IS 'Foreign key to the parent public.routes. 
Version: V2.'; -- [cite: 648] COMMENT ON COLUMN 
public.route_segments.segment_id IS 'Foreign key to the constituent 
public.segments. Version: V2.'; -- [cite: 649] COMMENT ON COLUMN 
public.route_segments.order_in_route IS 'The sequential, 1-based order of this 
segment within this route. Critical for path reconstruction and defining 
direction. Version: V2.'; -- [cite: 651] COMMENT ON COLUMN 
public.route_segments.contextual_notes_for_segment_in_route IS 'Optional notes 
specific to this segment when it is part of this particular route (English 
base, translatable via public.translations table using route_segments.id). 
Version: V2.'; -- [cite: 652] COMMENT ON COLUMN 
public.route_segments.created_at IS 'Timestamp of when this route-segment link 
was created. Version: V2.'; -- [cite: 653] COMMENT ON COLUMN 
public.route_segments.created_by_profile_id IS 'Profile ID (public.profiles.id) 
of the user who created this link. Version: V2.'; -- [cite: 654] COMMENT ON 
COLUMN public.route_segments.updated_at IS 'Timestamp of when this link record 
was last updated. Auto-updated by trigger. Version: V2.'; -- [cite: 655] 
COMMENT ON COLUMN public.route_segments.updated_by_profile_id IS 'Profile ID 
(public.profiles.id) of the user who last updated this link. Version: V2.'; -- 
[cite: 656] ``` 4\. JSON Schema Mirror JSON ``` { "title": 
"route_segment_link", "description": "Defines the ordered sequence of segments 
that make up a specific route, linking a route to its constituent path 
segments. Also triggers updates to route-level aggregate statistics. Version: 
V2.", "type": "object", "properties": { "id": { "type": "integer", "format": 
"int64", "description": "Unique identifier for this route-segment link record. 
Read-only.", -- [cite: 657] "readOnly": true }, "route_id": { "type": 
"integer", "format": "int64", "description": "Foreign key referencing the ID of 
the route (public.routes.id) this segment sequence belongs to." -- [cite: 658] 
}, "segment_id": { "type": "integer", "format": "int64", "description": 
"Foreign key referencing the ID of the segment (public.segments.id) being 
linked as part of the route." -- [cite: 659] }, "order_in_route": { "type": 
"integer", "minimum": 1, "description": "The sequential, 1-based order of this 
segment within this specific route. Defines the path construction sequence." -- 
[cite: 660] }, "contextual_notes_for_segment_in_route": { "type": ["string", 
"null"], "description": "Optional notes specific to this segment's role or 
characteristics when it is part of this particular route (English base, 
translatable using route_segments.id)." -- [cite: 661] }, "created_at": { 
"type": "string", "format": "date-time", "description": "Timestamp of when this 
link record was created. Read-only.", -- "readOnly": true }, 
"created_by_profile_id": { "type": ["string", "null"], "format": "uuid", 
"description": "Profile ID (public.profiles.id) of the user who created this 
link. Read-only.", -- "readOnly": true }, "updated_at": { "type": "string", 
"format": "date-time", "description": "Timestamp of when this link record was 
last updated. Read-only.", -- [cite: 662] "readOnly": true }, 
"updated_by_profile_id": { "type": ["string", "null"], "format": "uuid", 
"description": "Profile ID (public.profiles.id) of the user who last updated 
this link. Read-only.", -- "readOnly": true } }, "required": [ "route_id", 
"segment_id", "order_in_route", -- [cite: 663] "created_at", "updated_at" ], 
"primary_key": ["id"], -- [cite: 663] "unique_constraints": [ {"columns": 
["route_id", "order_in_route"], "name": 
"route_segments_route_id_order_in_route_key"} -- [cite: 663] ] } ``` 5\. 
Relationships & Integrity - Foreign Key Targets & `ON DELETE` Actions: - 
`route_id` references `public.routes(id)`: `ON DELETE CASCADE`. If a route is 
deleted, its sequence definition is also deleted. - `segment_id` references 
`public.segments(id)`: `ON DELETE CASCADE`. If a segment is deleted, it's 
removed from all route sequences. - `created_by_profile_id`, 
`updated_by_profile_id` references `public.profiles(id)`: `ON DELETE SET NULL`. 
- Primary Key: Surrogate `id` (`BIGINT`) for easy row reference, e.g., by the 
`translations` table. - Unique Constraint: `UNIQUE (route_id, order_in_route)` 
is critical for an unambiguous path for each route. - Segment Reusability: No 
`UNIQUE (route_id, segment_id)` constraint allows a segment to appear multiple 
times in the same route if needed (e.g., for loops). - Mermaid ER Diagram 
Snippet: Code snippet ``` erDiagram routes { bigint id PK text name real 
total_distance_km integer estimated_total_elevation_gain_meters } segments { 
bigint id PK text name real distance_km integer elevation_gain_meters } 
profiles { uuid id PK } route_segments { bigint id PK -- bigint route_id FK -- 
bigint segment_id FK -- integer order_in_route -- text 
contextual_notes_for_segment_in_route -- timestamptz created_at -- uuid 
created_by_profile_id FK -- timestamptz updated_at -- uuid 
updated_by_profile_id FK -- -- UNIQUE(route_id, order_in_route) } routes ||--|{ 
route_segments : "composed_of (CASCADE)" -- [cite: 680] segments ||--|{ 
route_segments : "is_part_of (CASCADE)" -- [cite: 680] route_segments }o--|| 
profiles : "created_by (SET NULL)" -- [cite: 681] route_segments }o--|| 
profiles : "updated_by (SET NULL)" -- [cite: 682] ``` 6\. Multilingual Strategy 
- Translatable Field: `contextual_notes_for_segment_in_route`. English base 
text is stored here. - Linking Mechanism: Translations via 
`public.translations` table, using `table_name='route_segments'`, 
`column_name='contextual_notes_for_segment_in_route'`, and 
`row_id=route_segments.id`. 7\. Role-Based Workflow & RLS Notes - Workflow 
Fields: Audit columns (`created_at`, `created_by_profile_id`, `updated_at`, 
`updated_by_profile_id`) track link creation/modification. - Note: The RLS 
policies outlined above rely on the existence and correct implementation of 
global RLS helper functions (e.g., public.has_role(TEXT) , 
public.is_platform_admin() , specific regional/trail management checks) that 
authenticate users and verify their roles stored in the public.profiles table." 
This reinforces that the table-specific RLS is part of a larger auth system. - 
RLS Policy Stubs (Conceptual): - Public Read Access: If parent route and trail 
are published. SQL ``` CREATE POLICY "Allow public read access to 
route_segments" ON public.route_segments FOR SELECT USING ( EXISTS ( SELECT 1 
FROM public.routes r JOIN public.trails t ON r.trail_id = t.id WHERE r.id = 
route_segments.route_id AND r.content_visibility_status = 'published' AND 
r.deleted_at IS NULL AND t.content_visibility_status = 'published' AND 
t.deleted_at IS NULL ) ); -- [cite: 689] ``` - Admin Full Access: Full CRUD via 
`public.is_platform_admin()`. - Regional Content Manager Access: Conditional 
access via `public.is_regional_manager_for_route(BIGINT)`. - Audit trigger 
`set_route_segment_modification_meta` is `SECURITY DEFINER`. 8\. ENUM vs. 
Lookup Discussion Not applicable directly; this is a junction table. 9\. UI/UX 
Enablement - Core Data for Route Construction: `route_id`, `segment_id`, 
`order_in_route` are fundamental for application logic. - Contextual 
Information: `contextual_notes_for_segment_in_route` for route-specific segment 
insights. - ðŸ”´ Trigger for Route Statistics: DML operations here trigger 
updates to `routes.total_distance_km` and 
`routes.estimated_total_elevation_gain_meters` ensuring UI accuracy. 10\. Key 
Considerations & Definitions - `order_in_route` Integrity: Paramount for 
correct path representation; must be a positive, sequential integer per 
`route_id`. Application layer manages this sequence. - Lifecycle: Dependent on 
parent `routes` and `segments` due to `ON DELETE CASCADE`. - Route 
Directionality: Implicitly defined by `order_in_route`. Reverse routes should 
be separate `routes` records. - Atomicity of Changes: Route 
assembly/modification operations should be transactional. 11\. Scalability & 
Future-Proofing - `BIGINT` PKs/FKs support growth. - Audit columns provide 
traceability. - No soft deletes needed; lifecycle tied to parents. - 
Performance: Indexes on FKs and the `UNIQUE (route_id, order_in_route)` 
constraint are crucial. The aggregate update trigger's performance for very 
long routes might be a V2+ consideration. 12\. Next-Action Checklist 1. ðŸ”´ 
Implement DDL: Create the `public.route_segments` table with all constraints 
(PK, FKs with `ON DELETE CASCADE`, `CHECK`, `UNIQUE`), indexes, and the 
`set_route_segment_modification_meta` trigger. 2. ðŸ”´ Implement and Test Route 
Aggregates Trigger: Ensure `public.update_route_aggregates_from_segments` 
trigger function is correctly implemented and thoroughly tested for `INSERT`, 
`UPDATE`, and `DELETE` operations on `public.route_segments`, verifying 
accurate updates to `routes` table statistics. 3. ðŸ”´ Implement Orphaned 
Translation Cleanup Trigger: Add an `AFTER DELETE` trigger on 
`public.route_segments` that calls 
`public.cleanup_related_translations('route_segments', OLD.id)` to remove 
orphaned translations for `contextual_notes_for_segment_in_route`. 4. ðŸŸ  
Implement RLS Policies & Helper Functions: Define, implement, and test RLS 
policies for `public.route_segments`, including helper functions like 
`public.is_platform_admin()` and 
`public.is_regional_manager_for_route(BIGINT)`. 5. ðŸŸ¢ Review Application Logic: 
Ensure the application layer correctly manages `order_in_route` during route 
assembly and modification. 6. ðŸŸ¢ Data Migration (if applicable): Plan and 
execute scripts to populate `route_segments`, mapping `route_id`, `segment_id`, 
and `order_in_route`. Populate audit columns. * * * * * 
