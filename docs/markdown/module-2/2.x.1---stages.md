# 2.x.1 - stages

  https://gemini.google.com/u/1/app/fc0ce8702c9586a4 3.3. Specific Trigger 
Implementations (Confirm and Test): Waypoint Vote Counts: Confirm DDL from 
Phase 2.1 for public.update_waypoint_vote_counts() . Trail Hierarchy Calcs: 
Confirm DDLs from Phase 2.2 for calculate_segment_geom_properties() , 
update_segment_geom_derived_fields() , update_route_aggregates_from_segments() 
. Relevant Modules: 2.0, 6.0. STAGES EXPLANATION Let's break down how trails , 
routes , segments , and route_segments work together, and then discuss how 
"stages" fit into this picture based on your insights. 1. The Core Hierarchy: 
Building Blocks of the Journey Think of it as a nested structure: trails Table 
What it is: This is the highest-level entity, representing an entire, 
overarching pilgrimage path. Example: "Via di Francesco," "Camino FrancÃ©s." Key 
Info: Overall name, general description, historical significance, perhaps a 
logo or banner image. It sets the grand context. Regional Context: A single 
trail can pass through multiple geographical regions (like Tuscany, Umbria). 
This is managed by the trail_regions table, which links a trail to the regions 
it traverses and can specify the order. routes Table What it is: Within a trail 
, there can be specific, named paths or significant variations. These are 
routes . A route typically has a defined start and end point (often towns or 
major waypoints) and represents a complete, navigable path choice for a 
significant portion of the trail . Example: For the "Via di Francesco" trail, 
you might have "Northern Route: La Verna to Assisi" or "Southern Route: Rome to 
Assisi." Or, as in your example, "Badia Prataglia to La Verna - Via Santicchio" 
could be one route , and "Badia Prataglia to La Verna - Via Biforco" could be 
another route . Key Info: Route-specific name, description, theme, overall GPX 
track URL (as a V1 link), and critically, auto-calculated aggregate statistics 
like total_distance_km and estimated_total_elevation_gain_meters . It can also 
be linked to alternative routes via alternative_to_route_id . segments Table 
What it is: These are the most granular, fundamental, and reusable building 
blocks of any path. Each segment connects two distinct waypoints (e.g., from a 
town to a specific albergue, or from one POI to the next significant junction). 
Example: "Consuma to Villa," "Villa to Gualdo," "Gualdo to Stia." Or "Badia 
Prataglia to Santicchio," "Santicchio to La Verna." Similarly, "Badia Prataglia 
to Biforco," "Biforco to La Verna." Key Info: The actual 3D path geometry ( 
path_geom ), from which its distance_km , elevation_gain_meters , 
elevation_loss_meters , and elevation_profile_data are auto-calculated. It also 
has detailed descriptions, terrain type, sun exposure, etc.. Segments can also 
represent detours for other segments ( is_detour_for_segment_id ). 
route_segments Table What it is: This is a crucial junction table . It defines 
how a specific route is constructed by linking it to an ordered sequence of 
segments . Example: For the route "Badia Prataglia to La Verna - Via 
Santicchio": route_id (for "Via Santicchio" route), segment_id (for "Badia 
Prataglia to Santicchio" segment), order_in_route = 1 route_id (for "Via 
Santicchio" route), segment_id (for "Santicchio to La Verna" segment), 
order_in_route = 2 Key Info: route_id , segment_id , and order_in_route . The 
order_in_route is essential for assembling the segments in the correct sequence 
to form the continuous path of the route. Critical Role: DML operations 
(INSERT, UPDATE, DELETE) on this table trigger the recalculation of aggregate 
statistics (like total distance and elevation) on the parent routes table. 2. 
How "Stages" Fit In (Current Schema & Your Clarification) You correctly 
articulated that "stages" represent a typical daily walk and are somewhat 
subjective. Given this: Current Status: "Stages" are not a distinct primary 
entity in the database as of the current specifications . Application-Level 
Construct: As you mentioned, "a stage would be an application level rendering 
of different segments." This is precisely how it would work with the current 
schema: The application (website/mobile app) would define what constitutes a 
"stage." This definition might come from official guidebooks, common pilgrim 
practice, or be curated by your platform's administrators. A "stage" would 
typically be defined by a widely recognized start waypoint and end waypoint for 
a day's journey. To display a "stage," the application would: Identify the 
relevant route(s) that connect these start and end waypoints of the conceptual 
stage. For each chosen route , query the route_segments table to get the 
ordered list of segments that make up that route between the stage's waypoints. 
Aggregate the information (distance, elevation, time) from these constituent 
segments to present the "stage" overview. Display the map by concatenating the 
path_geom of these ordered segments . 3. Handling Alternatives Within a "Stage" 
(Your Example: Stia to Badia Prataglia) Your example of Stia to Badia 
Prataglia, with options via Eremo di Camaldoli or the Monastery, is perfectly 
handled by the routes concept: Conceptual Stage: Stia (Start Waypoint) to Badia 
Prataglia (End Waypoint). Database Implementation: Route 1: "Stia to Badia 
Prataglia (via Eremo di Camaldoli)" This route would be linked in 
route_segments to a specific sequence of segments (e.g., "Stia to Eremo di 
Camaldoli" segment, then "Eremo di Camaldoli to Badia Prataglia" segment). 
Route 2: "Stia to Badia Prataglia (via Monastery)" This route would be linked 
in route_segments to a different sequence of segments (e.g., "Stia to 
Monastery" segment, then "Monastery to Badia Prataglia" segment). Application 
Display: When a pilgrim is planning the "stage" from Stia to Badia Prataglia, 
the application would identify that there are two (or more) distinct routes 
available to achieve this. It would then present these routes as choices to the 
pilgrim, each with its own total distance, elevation profile (derived from its 
unique segments), and description. So, the flexibility of having multiple 
routes (each a unique, ordered assembly of segments ) allows the platform to 
represent these common alternative paths that pilgrims might take to complete 
what they perceive as a single "stage" of their journey. 4. Regional Traversal 
within Stages/Routes A trail is explicitly linked to regions it traverses via 
trail_regions . Each segment is defined by a start_waypoint_id and 
end_waypoint_id . These waypoints are linked to towns (via waypoints.town_id 
from Module 4.0), and towns are linked to regions and provinces (Module 3.0). 
Therefore, as a route (and thus a conceptual "stage" composed of that route's 
segments) progresses from waypoint to waypoint, the application can determine 
the town , province , and region for each part of that stage by looking up the 
geographical context of its defining waypoints. A single stage can indeed span 
multiple towns or even regions if its constituent segments cross those 
boundaries. 5. Implications for Third-Party Data Access If "stages" remain 
purely an application-level construct: Third parties wanting to consume your 
data to display "stages" would need to replicate the logic your application 
uses. This might involve: Knowing the commonly accepted start/end waypoints for 
typical stages. Querying your routes and route_segments to find paths between 
these waypoints. Handling cases where multiple routes exist for a conceptual 
stage. This could be complex for them and might lead to inconsistencies if 
their stage definitions differ. The Case for a Future (Optional) stages Table: 
While your current approach is robust for your own application, if simplifying 
"stage" information for third-party consumption (or even for internal curation) 
becomes a priority, you could introduce a stages table in a future iteration. 
This would not replace segments or routes but would sit alongside them as a 
curated layer: stages Table (Conceptual): id (PK) trail_id (FK to trails ) 
stage_number (e.g., 1, 2, 3 for a given trail's "official" staging) name (e.g., 
"Stia to Badia Prataglia") - Translatable description - Translatable 
suggested_start_waypoint_id (FK to waypoints ) suggested_end_waypoint_id (FK to 
waypoints ) Other stage-specific metadata. stage_route_options Junction Table 
(Conceptual): stage_id (FK to stages ) route_id (FK to routes ) option_type 
(e.g., 'primary', 'official_variant', 'scenic_alternative') - Could be an ENUM 
or FK to a master table. display_order_for_stage Benefit: This would provide an 
explicit, queryable list of recognized stages and the route(s) that can be used 
to complete each stage. Third parties could then directly query this stages 
table. This would codify the "common understanding" of stages you mentioned, 
while still allowing those stages to be fulfilled by one or more of the 
meticulously defined routes (which are themselves built from segments ). In 
summary: Your current trails -> routes -> route_segments -> segments hierarchy 
is incredibly detailed and flexible. It accurately models the physical paths 
and their variations. "Stages" as daily walks can be effectively derived by the 
application from this structure. If you want to make "stages" a more explicit 
and easily consumable data point, particularly for third parties or for more 
rigid internal definition of an "official" sequence, a curated stages table 
linking to routes would be a logical future addition that builds upon the 
strong foundation you already have. I hope this comprehensive breakdown 
clarifies how these critical entities interoperate and relate to the concept of 
"stages"! WALKING DIRECTIONS 2. Walking Directions for "Routes" This is an 
excellent point and a common need for pilgrims! Here's how this could be 
handled, considering your existing schema: Current Schema for Descriptive Text: 
routes table has full_description and waymarking_and_navigation_details (both 
TEXT, translatable). segments table has detailed_description_notes and 
waymarking_on_segment_notes (both TEXT, translatable). How to Implement 
"Walking Directions": You have a few good options, depending on the desired 
granularity and format: Option A: Enhanced Segment Descriptions (Simplest for 
V1) Approach: Utilize the existing segments.detailed_description_notes field 
more explicitly for turn-by-turn or key navigational cues for that segment. 
Pros: Uses existing fields. Directions are tied to the most granular path unit. 
Cons: If directions are very long for each segment, it might make 
detailed_description_notes cumbersome. Combining these into a full route's 
directions would be an application-level task of concatenating notes from 
ordered segments. How it plays together: The application would fetch all 
segments for a chosen route (via route_segments ) in the correct order_in_route 
and then concatenate their detailed_description_notes (and potentially 
waymarking_on_segment_notes ) to form a continuous set of directions for the 
route. Option B: Route-Level "Walking Directions" Field (Good for Overview) 
Approach: Add a new TEXT field to the routes table, say 
walking_directions_narrative TEXT (translatable). This would store a 
consolidated narrative of walking directions for the entire route. Pros: 
Provides a single field for the entire route's directions. Simpler for 
displaying full route directions at once. Cons: Less granular. If a small part 
of a segment changes, the entire route narrative might need an update. Could 
become very long. How it plays together: This would be a manually curated field 
by content managers, summarizing the path based on its constituent segments. It 
doesn't replace segment-level details but offers a holistic view. Option C: 
Dedicated "Direction Steps" Table (Most Granular & Structured - Likely V2+) 
Approach: If you need highly structured, step-by-step directions (e.g., "Turn 
left at the old oak tree," "Continue 500m to the fountain"), you could create a 
new table: direction_steps (id PK, segment_id FK, order_in_segment INTEGER, 
instruction_text TEXT (translatable), distance_to_next_step_meters REAL, 
cue_image_media_id FK, geom_cue_point GEOMETRY(PointZ, 4326)) Pros: Very 
structured, allows for precise cues, images per step, and potentially 
interactive display on a map. Cons: Much higher data entry effort. 
Significantly more complex. How it plays together: The application would fetch 
all direction_steps for each segment in a route and display them in order. 
Option D: Using the articles Table (If Directions are Long-Form Narratives) 
Approach: If walking directions are more like descriptive, long-form guides for 
a route (rather than just concise step-by-step cues), an article (from the new 
articles table discussed in point 1) could be written for "Walking Directions 
for X Route" and then linked to the routes table. Linkage: Add a nullable 
walking_directions_article_id FK to the routes table, referencing articles.id . 
Pros: Allows for rich text, images, and a more editorial style for directions 
if desired. Utilizes the new articles system. Cons: Might be less "data-driven" 
for step-by-step cues if that's what's needed. Querying specific steps within 
the article is not straightforward. Recommendation for Walking Directions: For 
V1: Start with Option A (Enhanced Segment Descriptions) . Encourage content 
managers to include key navigational cues within 
segments.detailed_description_notes and segments.waymarking_on_segment_notes . 
The application can then assemble these for a route. You can also implement 
Option B (Route-Level Walking Directions Field) by adding 
walking_directions_narrative TEXT (translatable) to the routes table. This can 
hold a more general overview of the route's navigation. This dual approach 
(granular details on segments, summary on routes) gives good flexibility for 
V1. Option C is likely overkill for V1 unless extremely precise, app-guided 
turn-by-turn is a core immediate feature. Option D is good if the directions 
are more narrative and article-like. By enhancing the existing 
segments.detailed_description_notes and potentially adding a summary field to 
routes , you can provide comprehensive walking directions without immediately 
needing a complex new table structure for V1. The application would be 
responsible for collating the segment-level details into a cohesive set of 
directions for a chosen route. 
