# 5.0.2 - APi Concepts

  Key Conceptual API Endpoints Endpoint: List Active Warnings for a Trail 
Segment Purpose : To retrieve all currently active and publicly published 
warnings for a specific trail segment. Path Pattern : GET 
/segments/{segment_id}/warnings Query Params / Filters / Options : lang 
(optional, string, e.g., it ): ISO language code to request translations for 
display names and descriptions. include_image_variants (optional, boolean, 
default false ): If true, attempts to include pre-defined variants for the 
primary image from media.image_variants_json . limit (optional, integer, 
default 20 ): Number of warnings to return. offset (optional, integer, default 
0 ): Offset for pagination. Endpoint: Search Active Warnings by Geographical 
Area Purpose : To find and display all currently active and publicly published 
warnings within a given geographical bounding box, typically for map displays. 
Path Pattern : GET /warnings/search/geo Query Params / Filters / Options : bbox 
(required, string, e.g., minLng,minLat,maxLng,maxLat ): The bounding box 
coordinates (WGS84). lang (optional, string, e.g., it ): ISO language code for 
translations. include_image_variants (optional, boolean, default false ). limit 
(optional, integer, default 50 ): Maximum number of warnings to return. offset 
(optional, integer, default 0 ): Offset for pagination. min_severity_code 
(optional, string, e.g., caution_advised ): Filter warnings by minimum severity 
level (inclusive), based on warning_severities_master.sort_order . &lt;hr/> 
Example JSON Responses GET 
/segments/{segment_id}/warnings?lang=it&include_image_variants=true JSON [ { 
"warning_id" : 101 , "segment_id" : 42 , "title" : "Frana Minore" , // Assuming 
'it' translation was found "description_message" : "Piccola frana sul sentiero, 
prestare attenzione." , // 'it' translation "location_on_segment_description" : 
"Circa al km 2.5, vicino alla vecchia quercia." , // 'it' translation 
"location_on_segment_km_approx" : 2.5 , "location_on_segment_geom" : { /* 
GeoJSON PointZ object */ }, "detour_information_url" : 
"https://example.com/detour/101" , "detour_description_notes" : "Seguire la 
deviazione segnalata." , // 'it' translation "date_warning_reported" : 
"2025-05-15T10:00:00Z" , "date_warning_effective_from" : "2025-05-15T12:00:00Z" 
, "date_warning_expected_resolution" : "2025-05-25T17:00:00Z" , "warning_type" 
: { "code" : "hazard_natural_landslide" , "name" : "Pericolo Naturale - Frana" 
, // 'it' translation "icon_identifier" : "fas fa-mountain-city" }, 
"warning_severity" : { "code" : "caution_advised" , "name" : "Cautela 
Consigliata" , // 'it' translation "ui_color_hex" : "#F1C40F" }, 
"warning_source_type_name" : "Gestore Regionale" , // 'it' translation 
"primary_image_media_id" : "a1b2c3d4-e5f6-7890-1234-567890abcdef" , 
"primary_image_variants" : { // if include_image_variants=true and media record 
has variants "thumbnail_small" : "/media/variants/a1b2c3d4_thumb_s.webp" , 
"display_medium" : "/media/variants/a1b2c3d4_display_m.jpg" }, 
"translations_available" : [ "en" , "de" ] // Conceptual: languages for which 
full translation exists for this warning } ] GET 
/warnings/search/geo?bbox=12.0,43.0,12.5,43.5&limit=1 JSON [ { "warning_id" : 
105 , "segment_id" : 77 , "title" : "Bridge Damaged" , // Base language 
(English) as no 'lang' param specified "description_message" : "The small 
wooden bridge over the creek is damaged. Crossing is risky." , 
"location_on_segment_description" : "At the crossing of Fosso della Volpe." , 
"location_on_segment_km_approx" : 1.2 , "location_on_segment_geom" : { /* 
GeoJSON PointZ object */ }, "detour_information_url" : null , 
"detour_description_notes" : "Consider fording the creek upstream if water 
levels are low, otherwise backtrack." , "date_warning_reported" : 
"2025-05-18T09:30:00Z" , "date_warning_effective_from" : "2025-05-18T09:30:00Z" 
, "date_warning_expected_resolution" : null , "warning_type" : { "code" : 
"trail_damage_bridge" , "name" : "Trail Damage - Bridge" , "icon_identifier" : 
"icon-bridge-damage" }, "warning_severity" : { "code" : "hazard_significant" , 
"name" : "Significant Hazard / Consider Alternative" , "ui_color_hex" : 
"#E67E22" }, "warning_source_type_name" : "Official Authority" , 
"primary_image_media_id" : "b2c3d4e5-f6g7-8901-2345-67890abcdef0" , 
"primary_image_variants" : null // if include_image_variants=false or no 
variants } ] &lt;hr/> Database-Support Analysis For both conceptual endpoints, 
the primary data source would ideally be the 
public.public_active_segment_warnings_view . Endpoint: GET 
/segments/{segment_id}/warnings Indexes : The view itself queries 
segment_warnings using segment_id . An index on segment_warnings.segment_id is 
crucial and already defined ( idx_segment_warnings_segment_id ). The view also 
filters by is_currently_active = true and workflow_status_code = 'published' . 
The composite index idx_segment_warnings_is_currently_active_published is 
well-suited for this. Joins to master tables use their PKs ( id ), which are 
indexed. Sufficient : Yes, existing indexes on base tables and those supporting 
the view's WHERE clause are good. Join Complexity : The 
public_active_segment_warnings_view already encapsulates the necessary joins 
(to warning_types_master , warning_severities_master , 
warning_source_types_master ). If include_image_variants=true , an additional 
LEFT JOIN to public.media on primary_image_media_id would be needed if not 
already part of the core view. This is a simple join on an indexed FK. Fetching 
translations would involve separate lookups to the public.translations table 
per translatable field, per warning, if the API handles translation assembly. 
Recommendation : The view greatly simplifies this. For translations, the API 
backend would query public.translations using 
table_identifier='segment_warnings' , row_foreign_key=warning_id , 
column_identifier IN (...) , and the requested language_code . This can be 
optimized. Performance Gotchas : RLS on segment_warnings and master tables will 
be applied. If the RLS policies are complex or involve many subqueries, they 
could add overhead. However, the view is for public data, so RLS for an 
anonymous/authenticated role should be straightforward. The number of warnings 
per segment is expected to be low, so performance should be good. Missing Data? 
: The concept of translations_available in the example JSON is not directly 
stored. The API backend would need to determine this, perhaps by checking 
existing translations for a given warning_id . Endpoint: GET 
/warnings/search/geo (using bbox ) Indexes : Crucially relies on the GIST index 
on segment_warnings.location_on_segment_geom ( 
idx_segment_warnings_location_geom ) for efficient spatial queries (e.g., using 
ST_MakeEnvelope and && operator). The view's filters on is_currently_active and 
workflow_status_code are also important, covered by 
idx_segment_warnings_is_currently_active_published . Sufficient : Yes, provided 
the GIST index is correctly utilized. Join Complexity : Similar to the first 
endpoint, the view handles base joins. The geo query itself is on 
segment_warnings.location_on_segment_geom . Filtering by min_severity_code 
would require joining warning_severities_master (if not already in the view in 
a way that allows filtering on sort_order associated with the code) or an 
efficient lookup of sort_order from code to apply to the view's 
warning_severity_code or a derived warning_severity_sort_order . The 
public_active_segment_warnings_view already includes warning_severity_code and 
warning_severity_name . Adding wsm.sort_order AS warning_severity_sort_order to 
the view would be beneficial for this filter. Performance Gotchas : Spatial 
queries can be intensive if the dataset is huge and the bbox is very large, but 
with proper indexing and typical warning volumes, it should be manageable. 
Pagination ( limit / offset ) on geo-queries needs careful handling, often best 
combined with a deterministic sort order (e.g., date_warning_reported DESC ) to 
ensure stable results if not sorting by distance (which is a different query 
type). Missing Data? : To filter by min_severity_code effectively based on 
hierarchy, the sort_order from warning_severities_master should be easily 
accessible, ideally exposed by the view. &lt;hr/> Immediate Schema Tweaks (if 
any) ðŸŸ¢ Add sort_order from warning_severities_master to 
public_active_segment_warnings_view : Reason : To efficiently support the 
min_severity_code filter on the /warnings/search/geo endpoint by allowing 
filtering on the numerical sort_order . Change : Modify 
public_active_segment_warnings_view DDL: SQL -- In SELECT list: wsm.sort_order 
AS warning_severity_sort_order ðŸŸ¢ Consider adding media.image_variants_json to 
public_active_segment_warnings_view : Reason : If include_image_variants=true 
is a common API parameter, embedding the image_variants_json directly into the 
view (if primary_image_media_id is not null) could simplify API logic by 
avoiding an N+1 query problem or a secondary join at the API level. Change : 
Modify public_active_segment_warnings_view DDL: SQL -- Add LEFT JOIN to media: 
-- LEFT JOIN public.media m ON sw.primary_image_media_id = m.id -- In SELECT 
list: -- m.image_variants_json AS primary_image_variants_json Note : This makes 
the view slightly heavier, but potentially more convenient for API consumers. 
ðŸŸ  Standardize Translatable Object Representation in API : Reason : The example 
JSON shows title: "Frana Minore" directly using the translated string. A more 
robust API might return an object for translatable fields, e.g., title: { 
"text": "Frana Minore", "lang": "it", "base_text": "Minor Landslide" } or 
provide a clear mechanism for clients to request specific translations using 
the translations table structure. The current 
public_active_segment_warnings_view only provides base language text. Change : 
This is more of an API design/backend logic decision than a direct schema tweak 
to this module's tables , but it impacts how data from the view is processed 
and enriched with translations from public.translations . For the database, 
ensuring efficient querying of public.translations is key (e.g., good indexing 
on table_identifier, column_identifier, row_foreign_key, language_code ). No 
direct schema change to this module's DDLs from this point, but a reminder for 
overall API consistency. No ðŸ”´ must-fix items identified for the current 
database schema of the Dynamic Conditions Module based solely on these 
conceptual API endpoints, assuming the proposed view is adopted and slightly 
enhanced. The existing tables and the proposed view provide a strong 
foundation. 
