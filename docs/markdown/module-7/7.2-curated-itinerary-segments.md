# 7.2 curated_itinerary_segments

  
https://gemini.google.com/u/1/app/b76d14705d5101f9?is_sa=1&android-min-version=3
01356232&ios-min-version=322.0&campaign_id=bkws&utm_source=google&utm_medium=cpc
&utm_campaign=2024enUS_gemfeb&pt=9008&mt=8&ct=p-growth-sem-bkws 
https://gemini.google.com/u/1/app/42a77d08d7a45bcb ### 3\. Updated 
Production-Ready Specification * * * * * Production-Ready Specification: 
public.curated_itinerary_segments Table Version: 2.1 (V2.1 Checklist REV 
05-18-25-A Applied) Date: May 18, 2025 1\. Purpose & Primary Use-Cases Defines 
the ordered sequence of specific path segments that constitute each curated 
itinerary, assigning each segment to a particular day and an order within that 
day. This table acts as the "playlist" or "recipe" that constructs an itinerary 
from foundational segment data. Crucially, it also triggers updates to 
aggregate statistics on the parent `routes` table. *Key User-Story 
Touchpoints:* - Pilgrim (Anna): Enables the day-by-day breakdown of curated 
itineraries (A2 & A7); essential for offline packaging (A10). - Platform 
Administrator (Admin Team) / Regional Content Manager (Sofia): Core to 
constructing and defining curated itineraries (D2). - Application Logic: DML 
operations on this table trigger updates to aggregated statistics on parent 
`routes` table. 2\. Schema | Column | Data Type | Constraints | Description 
(Translatable fields marked) | | `id` | `bigint` | Primary Key, Generated 
always as identity | Unique identifier for this itinerary-segment link. | | 
`itinerary_id` | `bigint` | Foreign Key to `curated_itineraries(id)` ON DELETE 
CASCADE, Not Null | The curated itinerary this entry belongs to. | | 
`segment_id` | `bigint` | Foreign Key to `segments(id)` ON DELETE RESTRICT, Not 
Null | The specific segment that is part of this itinerary. ON DELETE RESTRICT 
prevents segment deletion if used. | | `day_number_in_itinerary` | `integer` | 
Not Null, `CHECK (day_number_in_itinerary > 0)` | Assigns this segment to a 
specific "day" within the itinerary (e.g., Day 1). | | 
`order_of_segment_within_day` | `integer` | Not Null, Default 1, `CHECK 
(order_of_segment_within_day > 0)` | If a "day" comprises multiple segments, 
this defines their sequence for that day. | | `notes_for_segment_in_itinerary` 
| `text` | Nullable | Contextual notes for this segment as it appears in this 
specific itinerary and day (Base language: English). (Translatable) | | 
`is_optional_segment_for_day` | `boolean` | Not Null, Default `false` | Flags 
if this segment is an optional side trip or alternative for this particular 
day. | | `created_at` | `timestamp with time zone` | Not Null, Default `now()` 
| Timestamp of record creation. | | `created_by_profile_id` | `uuid` | Foreign 
Key to `public.profiles(id)` ON DELETE SET NULL, Nullable | Profile ID of the 
user who created this link. | | `updated_at` | `timestamp with time zone` | Not 
Null, Default `now()` | Timestamp of last update (auto-updated by trigger). | | 
`updated_by_profile_id` | `uuid` | Foreign Key to `public.profiles(id)` ON 
DELETE SET NULL, Nullable | Profile ID of user who last updated this record. | 
| | | `UNIQUE (itinerary_id, day_number_in_itinerary, 
order_of_segment_within_day)` | Ensures each segment has a unique ordered 
position within a specific day of an itinerary. | 3\. PostgreSQL DDL SQL ``` 
CREATE TABLE public.curated_itinerary_segments ( id BIGINT GENERATED ALWAYS AS 
IDENTITY PRIMARY KEY, itinerary_id BIGINT NOT NULL REFERENCES 
public.curated_itineraries(id) ON DELETE CASCADE, segment_id BIGINT NOT NULL 
REFERENCES public.segments(id) ON DELETE RESTRICT, -- Corrected type to BIGINT 
day_number_in_itinerary INTEGER NOT NULL CHECK (day_number_in_itinerary > 0), 
order_of_segment_within_day INTEGER NOT NULL DEFAULT 1 CHECK 
(order_of_segment_within_day > 0), notes_for_segment_in_itinerary TEXT, -- 
(Translatable) is_optional_segment_for_day BOOLEAN NOT NULL DEFAULT FALSE, 
created_at TIMESTAMPTZ NOT NULL DEFAULT now(), created_by_profile_id UUID 
REFERENCES public.profiles(id) ON DELETE SET NULL, updated_at TIMESTAMPTZ NOT 
NULL DEFAULT now(), updated_by_profile_id UUID REFERENCES public.profiles(id) 
ON DELETE SET NULL, CONSTRAINT uq_itinerary_day_segment_sequence UNIQUE 
(itinerary_id, day_number_in_itinerary, order_of_segment_within_day) ); -- 
Indexes CREATE INDEX IF NOT EXISTS idx_curated_itinerary_segments_itinerary_id 
ON public.curated_itinerary_segments(itinerary_id); CREATE INDEX IF NOT EXISTS 
idx_curated_itinerary_segments_segment_id ON 
public.curated_itinerary_segments(segment_id); -- Composite index for ordering, 
uq_itinerary_day_segment_sequence also creates an index CREATE INDEX IF NOT 
EXISTS idx_curated_itinerary_segments_day_order ON 
public.curated_itinerary_segments(itinerary_id, day_number_in_itinerary, 
order_of_segment_within_day); CREATE INDEX IF NOT EXISTS 
idx_curated_itinerary_segments_created_by ON 
public.curated_itinerary_segments(created_by_profile_id) WHERE 
created_by_profile_id IS NOT NULL; CREATE INDEX IF NOT EXISTS 
idx_curated_itinerary_segments_updated_by ON 
public.curated_itinerary_segments(updated_by_profile_id) WHERE 
updated_by_profile_id IS NOT NULL; -- Comments COMMENT ON TABLE 
public.curated_itinerary_segments IS 'Defines the ordered sequence of specific 
segments that constitute each curated itinerary, assigning each to a day and 
order. Version 2.1.'; COMMENT ON COLUMN public.curated_itinerary_segments.id IS 
'PK. Unique identifier for this itinerary-segment link. Version 2.1.'; COMMENT 
ON COLUMN public.curated_itinerary_segments.itinerary_id IS 'The curated 
itinerary this entry belongs to. FK to public.curated_itineraries.id. ON DELETE 
CASCADE. Version 2.1.'; COMMENT ON COLUMN 
public.curated_itinerary_segments.segment_id IS 'The specific segment that is 
part of this itinerary. FK to public.segments.id. ON DELETE RESTRICT. Version 
2.1.'; COMMENT ON COLUMN 
public.curated_itinerary_segments.day_number_in_itinerary IS 'Assigns this 
segment to a specific "day" within the itinerary (e.g., Day 1, Day 2). Must be 
> 0. Version 2.1.'; COMMENT ON COLUMN 
public.curated_itinerary_segments.order_of_segment_within_day IS 'If a "day" 
comprises multiple segments, this defines their sequence for that day (e.g., 
Part 1, Part 2 of Day 1). Must be > 0. Default 1. Version 2.1.'; COMMENT ON 
COLUMN public.curated_itinerary_segments.notes_for_segment_in_itinerary IS 
'Contextual notes for this segment as it appears in this specific itinerary and 
day (Base language: English). Translatable via public.translations (using 
curated_itinerary_segments.id). Version 2.1.'; COMMENT ON COLUMN 
public.curated_itinerary_segments.is_optional_segment_for_day IS 'Flags if this 
segment is an optional side trip or alternative for this particular day within 
this itinerary. Default false. Version 2.1.'; COMMENT ON COLUMN 
public.curated_itinerary_segments.created_at IS 'Timestamp of record creation. 
Version 2.1.'; COMMENT ON COLUMN 
public.curated_itinerary_segments.created_by_profile_id IS 'Profile ID of the 
user who created this link. FK to public.profiles.id. ON DELETE SET NULL. 
Version 2.1.'; COMMENT ON COLUMN public.curated_itinerary_segments.updated_at 
IS 'Timestamp of last update (auto-updated by trigger). Version 2.1.'; COMMENT 
ON COLUMN public.curated_itinerary_segments.updated_by_profile_id IS 'Profile 
ID of the user who last updated this record. FK to public.profiles.id. ON 
DELETE SET NULL. Version 2.1.'; COMMENT ON CONSTRAINT 
uq_itinerary_day_segment_sequence ON public.curated_itinerary_segments IS 
'Ensures each segment has a unique ordered position within a specific day of an 
itinerary. Version 2.1.'; ``` 4\. Triggers/Functions - Audit Metadata Trigger: 
SQL ``` -- Using a generic linking table audit trigger. Ensure it exists or 
create it: -- CREATE OR REPLACE FUNCTION 
public.set_linking_table_audit_meta()... (as defined in previous fix) CREATE 
TRIGGER trigger_set_curated_itinerary_segments_audit_meta BEFORE INSERT OR 
UPDATE ON public.curated_itinerary_segments FOR EACH ROW EXECUTE FUNCTION 
public.set_linking_table_audit_meta(); ``` *Comment on Trigger*: Manages 
`created_at`, `updated_at`, `created_by_profile_id`, and 
`updated_by_profile_id` columns. - Orphaned Translation Cleanup Trigger: SQL 
``` CREATE OR REPLACE FUNCTION 
public.cleanup_curated_itinerary_segments_translations() RETURNS TRIGGER AS $$ 
BEGIN DELETE FROM public.translations WHERE table_identifier = 
'curated_itinerary_segments' AND row_foreign_key = OLD.id::text; -- Using the 
surrogate PK 'id' RETURN OLD; END; $$ LANGUAGE plpgsql SECURITY DEFINER; ALTER 
FUNCTION public.cleanup_curated_itinerary_segments_translations() SET 
search_path = public; CREATE TRIGGER 
trigger_cleanup_curated_itinerary_segments_translations AFTER DELETE ON 
public.curated_itinerary_segments FOR EACH ROW EXECUTE FUNCTION 
public.cleanup_curated_itinerary_segments_translations(); ``` *Comment on 
Trigger*: After a `curated_itinerary_segments` record is deleted, this trigger 
removes any associated translations for `notes_for_segment_in_itinerary`. - 
Route Aggregates Trigger (Reference): - This table's DML operations should 
trigger `public.update_route_aggregates_from_segments()` AFTER INSERT OR UPDATE 
OR DELETE on `public.route_segments` (if `curated_itinerary_segments` directly 
impacts `routes` table stats, which it doesn't seem to based on the current 
context where `route_segments` is the direct link for route stats). If 
`curated_itineraries` also needs its own aggregate stats based on these 
segments, a similar trigger would be needed. For now, assuming this table does 
not directly update `routes` or `curated_itineraries` aggregate fields. The 
provided `route_segments.docx` (doc 2.5) handles `routes` table aggregates. 5\. 
JSON Schema Mirror JSON ``` { "title": "curated_itinerary_segment_link", 
"description": "Defines the ordered sequence of specific segments that make up 
each curated_itinerary, assigning each to a day and order. Version 2.1.", 
"type": "object", "properties": { "id": { "type": "integer", "format": "int64", 
"readOnly": true, "description": "PK. Unique identifier for this 
itinerary-segment link. Version 2.1." }, "itinerary_id": { "type": "integer", 
"format": "int64", "description": "The curated itinerary this entry belongs to. 
FK to public.curated_itineraries.id. Version 2.1." }, "segment_id": { "type": 
"integer", "format": "int64", /* Corrected from original "integer" to "int64" 
to match BIGINT */ "description": "The specific segment that is part of this 
itinerary. FK to public.segments.id. Version 2.1." }, 
"day_number_in_itinerary": { "type": "integer", "minimum": 1, "description": 
"Assigns this segment to a specific \"day\" within the itinerary. Must be > 0. 
Version 2.1." }, "order_of_segment_within_day": { "type": "integer", "minimum": 
1, "default": 1, "description": "If a \"day\" comprises multiple segments, this 
defines their sequence for that day. Must be > 0. Default 1. Version 2.1." }, 
"notes_for_segment_in_itinerary": { "type": ["string", "null"], "description": 
"Contextual notes for this segment as it appears in this itinerary and day 
(Base language: English). Translatable via public.translations. Version 2.1." 
}, "is_optional_segment_for_day": { "type": "boolean", "default": false, 
"description": "Flags if this segment is an optional side trip or alternative 
for this day. Default false. Version 2.1." }, "created_at": { "type": "string", 
"format": "date-time", "readOnly": true, "description": "Timestamp of record 
creation. Read-only. Version 2.1." }, "created_by_profile_id": { "type": 
["string", "null"], "format": "uuid", "description": "Profile ID of the user 
who created this link. FK to public.profiles.id. Read-only. Version 2.1.", 
"readOnly": true }, "updated_at": { "type": "string", "format": "date-time", 
"readOnly": true, "description": "Timestamp of last update (auto-updated by 
trigger). Read-only. Version 2.1." }, "updated_by_profile_id": { "type": 
["string", "null"], "format": "uuid", "description": "Profile ID of user who 
last updated this record. FK to public.profiles.id. Read-only. Version 2.1.", 
"readOnly": true } }, "required": [ "itinerary_id", "segment_id", 
"day_number_in_itinerary", "order_of_segment_within_day", 
"is_optional_segment_for_day", "created_at", "updated_at" ], "primary_key": 
["id"], "unique_constraints": [ { "columns": ["itinerary_id", 
"day_number_in_itinerary", "order_of_segment_within_day"], "name": 
"uq_itinerary_day_segment_sequence" } ] } ``` 6\. Relationships & Integrity - 
`itinerary_id` -> `public.curated_itineraries(id)`: `ON DELETE CASCADE`. - 
`segment_id` -> `public.segments(id)`: `ON DELETE RESTRICT`. - Audit FKs -> 
`public.profiles(id)`: `ON DELETE SET NULL`. - Surrogate PK: `id BIGINT`. - 
Unique Constraint: `uq_itinerary_day_segment_sequence (itinerary_id, 
day_number_in_itinerary, order_of_segment_within_day)`. - Mermaid ER Snippet: 
Code snippet ``` erDiagram curated_itineraries { bigint id PK } segments { 
bigint id PK } profiles { uuid id PK } curated_itinerary_segments { bigint id 
PK bigint itinerary_id FK bigint segment_id FK integer day_number_in_itinerary 
integer order_of_segment_within_day uuid created_by_profile_id FK uuid 
updated_by_profile_id FK UNIQUE (itinerary_id, day_number_in_itinerary, 
order_of_segment_within_day) } translations { bigint id PK } 
curated_itineraries ||--|{ curated_itinerary_segments : "defines sequence for 
(CASCADE)" segments ||--o{ curated_itinerary_segments : "is part of (RESTRICT)" 
curated_itinerary_segments }o--|| profiles : "created_by (SET NULL)" 
curated_itinerary_segments }o--|| profiles : "updated_by (SET NULL)" 
curated_itinerary_segments ||..o| translations : "has_translation_for_notes 
(via id)" ``` 7\. Multilingual Strategy - Translatable Field: 
`notes_for_segment_in_itinerary`. Base language (English) stored directly. - 
Translations via `public.translations` linked by `table_identifier = 
'curated_itinerary_segments'`, `column_identifier = 
'notes_for_segment_in_itinerary'`, and `row_foreign_key = 
curated_itinerary_segments.id::TEXT`. 8\. Role-Based Workflow & RLS Notes - 
Workflow Fields: Audit columns. Lifecycle tied to parent `curated_itineraries`. 
- RLS Policies (Conceptual): Mirror access rights for the parent 
`curated_itineraries` table. - Admins/Content Managers with Itinerary Edit 
Rights: Full CUD access. - Authenticated/Anonymous Users: `SELECT` access if 
parent itinerary is published and not deleted. 9\. ENUM vs Lookup Discussion - 
⚪ N/A directly. 10\. UI/UX Enablement - Core for ordering/grouping segments 
into daily stages. - `notes_for_segment_in_itinerary` provides context. - 
`is_optional_segment_for_day` flags optional parts. - Indexes support efficient 
fetching. 11\. Auditing & Lifecycle Management - Audit Columns: `created_at`, 
`updated_at`, `created_by_profile_id`, `updated_by_profile_id`. - Lifecycle: No 
soft delete; tied to parent `curated_itineraries` (CASCADE) or explicit link 
deletion. 12\. Scalability & Future-Proofing - `id` as `bigint`. - Indexes for 
performance. - No soft deletion directly on this table. 13\. Seed Data - ⚪ N/A 
- Transactional linking data. 14\. Next-Action Checklist - 🔴 Implement DDL: 
Execute `CREATE TABLE` for `public.curated_itinerary_segments` with corrected 
`segment_id` type, audit columns, constraints, and indexes. - 🔴 Implement 
Audit Trigger: Create and apply `public.set_linking_table_audit_meta`. - 🔴 
Implement Orphaned Translation Cleanup Trigger: Create and apply 
`public.cleanup_curated_itinerary_segments_translations`. - 🟠 Verify FK Data 
Types: Confirm `curated_itineraries.id` is `bigint`, `segments.id` is `bigint`, 
and `profiles.id` is `uuid`. - 🟠 Implement RLS Policies and any helper 
functions. - 🟢 Review Application Logic for `order_in_route` management. - 🟢 
Test `ON DELETE CASCADE` from `curated_itineraries` and `ON DELETE RESTRICT` 
for `segments`. * * * * * 
